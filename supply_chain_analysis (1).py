# -*- coding: utf-8 -*-
"""supply_chain_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/150vKtdG63pXCtRld-cwhZysQxH5eKc_i
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import sqlite3
from google.colab import files
upload=files.upload()

df=pd.read_csv("DataCoSupplyChainDataset.csv", encoding='latin-1')
df.head()

df.isnull().sum().sum()

df.drop(columns=["Order Zipcode", "Product Description"], inplace=True)
df.isnull().sum().sum()      #### order zipcode and product description column were completely null thus had to remove it from the data

df.dropna(inplace=True)
df.isnull().sum().sum()

df.info()

print("Customer Id has duplicates:", df.duplicated(["Customer Id"]).sum())
print("Order ID has duplicaes:",df.duplicated(["Order Id"]).sum())
print("Oreder Item Id is unique no duplicates present:",df.duplicated(["Order Item Id"]).sum())

"""## SQlite connection and database formation"""

connect=sqlite3.connect("supply_chain.db")
cursor=connect.cursor()

# Created a table named 'supply_chain' from the DataFrame
df.to_sql("supply_chain", connect, if_exists="replace", index=False)

# Query data from the table
query = "SELECT * FROM supply_chain;"
result = pd.read_sql_query(query, connect)


result.head()

df["order date (DateOrders)"]

query = 'SELECT "order date (DateOrders)" AS order_date, "Sales" FROM supply_chain;'
date_sales = pd.read_sql_query(query, connect)
date_sales.head()

"""## Monthly trend analysis"""

date_sales["order_date"] = pd.to_datetime(date_sales["order_date"], format="%m/%d/%Y %H:%M", errors="coerce")  ###datetime format conversion from order date



# Group by month and sum total sales
date_sales["year_month"] = date_sales["order_date"].dt.to_period("M").astype(str)
date_sales
monthly_sales = date_sales.groupby("year_month")["Sales"].sum().reset_index()
monthly_sales.head()

plt.figure(figsize=(12,6))
sns.lineplot(x=monthly_sales["year_month"], y=monthly_sales["Sales"], palette="plasma")
plt.title(" Monthly Total Sales Trend")
plt.xlabel("Month")
plt.ylabel("Total Sales")
plt.xticks(rotation=45)
plt.show()

"""### Top products that contributing the revenue"""

query = """
SELECT "Product Name", SUM("Order Item Total") AS revenue
FROM supply_chain
GROUP BY "Product Name"
ORDER BY revenue DESC
LIMIT 10;
"""
df_top_products = pd.read_sql_query(query, connect)
df_top_products
                                ### Field & Stream Sportsman 16 Gun Fire Safe ahs the higest contribution in the revenue which is	6.226935e+06

plt.figure(figsize=(8,5))
sns.barplot( x=df_top_products['revenue'], y=df_top_products['Product Name'], palette="viridis")
plt.title('Top 10 Products by Revenue')
plt.xlabel('Revenue')
plt.tight_layout()
plt.show()

"""### Top department by average profit"""

query = """
SELECT "Department Name",
    AVG("Order Profit Per Order") AS avg_profit,
    SUM("Order Profit Per Order") AS total_profit,
    COUNT("Department Name") AS count
FROM supply_chain
GROUP BY "Department Name"
ORDER BY avg_profit DESC
LIMIT 15;
"""
df_dept = pd.read_sql_query(query, connect)
plt.figure(figsize=(8,5))
sns.barplot(x=df_dept['avg_profit'], y=df_dept['Department Name'], palette="magma")
plt.title('Top Departments by Average Order Profit')
plt.xlabel('Average Profit per Order')
plt.tight_layout()
plt.show()                                         ### techonology has the highest average profit

"""## Top country based on total sales  """

query = """
SELECT "Customer Country" AS country, SUM("Sales") AS total_sales
FROM supply_chain
GROUP BY country
ORDER BY total_sales DESC;
"""
df_country = pd.read_sql_query(query, connect)
df_country
                                                            ### EE. UU. has highest total_sales

"""## Average shipping days by shipping


"""

query = """
SELECT "Shipping Mode",
       AVG("Days for shipping (real)") AS avg_days_real,
       AVG("Order Item Total") AS avg_order_value,
       COUNT(*) AS n_orders
FROM supply_chain
GROUP BY "Shipping Mode"
ORDER BY avg_days_real;
"""
df_shipmode = pd.read_sql_query(query, connect)
df_shipmode                                                     ### standard class has the highest number of orders and its takes more days to ship (4 days).
                                                                ### while first class shipping takes 2 days.

plt.figure(figsize=(8,5))
sns.barplot(data=df_shipmode, x='avg_days_real', y='Shipping Mode', palette="viridis")
plt.title('Average Real Shipping Days by Shipping Mode')
plt.xlabel('Avg Days')
plt.tight_layout()
plt.show()

"""## Delay percentage by shipping modes"""

query_delivery = """
SELECT "Shipping Mode",
    AVG("Days for shipping (real)" - "Days for shipment (scheduled)") AS avg_delay,
    SUM(CASE WHEN "Days for shipping (real)" > "Days for shipment (scheduled)"
        THEN 1 ELSE 0 END) AS delayed_orders,
    COUNT(*) AS total_orders,
    AVG("Days for shipping (real)") AS avg_real_days,
    AVG("Days for shipment (scheduled)") AS avg_scheduled_days
FROM supply_chain
GROUP BY "Shipping Mode"
ORDER BY avg_delay DESC
"""
df_delivery = pd.read_sql_query(query_delivery, connect)
df_delivery

# Calculate delay percentage
df_delivery['delay_percentage'] = (df_delivery['delayed_orders'] / df_delivery['total_orders'] * 100).round(2)
# print(" Delivery Performance Summary:")
print(df_delivery.to_string(index=False))

                                                                                       ### standard class has lowest delay percentage(39.77)
                                                                                       ### fisrt class has highest delay percentage (100)

# Visualization 1: delay percentage by Shipping Mode
plt.figure(figsize=(8, 5))
sns.barplot(data=df_delivery, x='Shipping Mode', y="delay_percentage", palette='inferno')
plt.title("Average Delivery Delay by Shipping Mode")
plt.ylabel('Average Delay (Days)')
plt.xlabel('Shipping Mode')
plt.legend()
plt.show()

"""## Customer segments sales analysis"""

query = """
SELECT "Customer Segment",
       COUNT(DISTINCT "Customer Id") AS n_customers,
       SUM("Sales") AS total_sales,
       AVG("Sales") AS avg_sales_per_record
FROM supply_chain
GROUP BY "Customer Segment"
ORDER BY total_sales DESC;
"""
df_seg = pd.read_sql_query(query, connect)
df_seg

plt.figure(figsize=(8,5))
sns.barplot( x=df_seg['total_sales'], y=df_seg['Customer Segment'], palette="plasma")    ### consumer segment has highest contribution in sales
plt.title('Sales by Customer Segment')
plt.show()

"""### Top 10 customers by total sales"""

query = """
SELECT "Customer Id", "Customer Fname", "Customer Lname",
       SUM("Sales") AS total_sales,
       COUNT(DISTINCT "Order Id") AS n_orders
FROM supply_chain
GROUP BY "Customer Id"
ORDER BY total_sales DESC
LIMIT 10;
"""
df_top_customers = pd.read_sql_query(query, connect)                      # Customer ID 791 has highest total sales
plt.figure(figsize=(8,5))
sns.barplot(data=df_top_customers, y='total_sales', x='Customer Id', palette="plasma")
plt.title('Top 5 Customers by Total Sales')
plt.tight_layout()
plt.show()

"""### Order Status Distribution"""

query = """
SELECT "Order Status", COUNT("Order Status") AS status
FROM supply_chain
GROUP BY "Order Status"
ORDER BY status DESC;
"""
df_status = pd.read_sql_query(query, connect)
df_status
                                                        ### most of the order count has been completed to be extact 59487 orders has been completed.
                                                        ### 1893 orders are in payment review, 9803 orders are in on hold and 20224 orders are pending.

plt.figure(figsize=(8,5))
sns.barplot(x=df_status['status'], y=df_status['Order Status'], palette="viridis")
plt.title('Order Status Distribution')
plt.xlabel('Count')
plt.tight_layout()
plt.show()

"""## Top 10 category name based on order item total value






"""

query = """
SELECT "Category Name",
       AVG("Order Item Total") AS avg_order_value,
       SUM("Order Item Total") AS total_value,
       COUNT(*) AS n_items
FROM supply_chain
GROUP BY "Category Name"
ORDER BY total_value DESC
LIMIT 10;
"""
df_cat = pd.read_sql_query(query, connect)
df_cat.head(10)                                        ### fishing category has the highest order item total

plt.figure(figsize=(8,5))
sns.barplot(x=df_cat['total_value'], y=df_cat['Category Name'], palette="inferno")
plt.title('Top Categories by Total Order Item Value')
plt.xlabel('Total Value')
plt.tight_layout()
plt.show()

"""### Geographical distribution of orders"""

query = """
SELECT "Latitude", "Longitude", "Sales"
FROM supply_chain
WHERE "Latitude" IS NOT NULL AND "Longitude" IS NOT NULL
"""
df_geo = pd.read_sql_query(query, connect)
plt.figure(figsize=(6,6))
sns.scatterplot(x=df_geo['Longitude'], y=df_geo['Latitude'], hue=df_geo["Sales"], palette="viridis")
plt.title('Orders by Geographic Coordinates (sample)')
plt.xlabel('Longitude'); plt.ylabel('Latitude')
plt.show()

                                                                                 ### most of the orders came from longitude, latitude (-100,40)

"""## Top 20 customers by Total Quantity Purchased"""

query="""select count("Order Item ID") as order_item_count, sum("Order Item Quantity") as total_item_quant,
"Customer ID" from supply_chain group by "Customer ID" order by order_item_count desc limit 20;"""

item_count=pd.read_sql_query(query, connect)
item_count                                                         #customer id 5004 has highest total intem quantity and while 5654 has highest order item counts.

plt.figure(figsize=(8,6))

sns.barplot(
    data=item_count,
    x='Customer Id',
    y='total_item_quant',
    hue='order_item_count',
    palette='inferno'
)

plt.title('Top 20 Customers by Total Quantity Purchased', fontsize=13)
plt.xlabel('Customer ID')
plt.ylabel('Total Quantity of Items Purchased')
plt.xticks(rotation=45)
plt.legend(title='Order Item Count')
plt.tight_layout()
plt.show()

"""## Cutomer ID and its number of orders"""

query_counts = """
-- number of distinct orders per customer
SELECT distinct
  "customer Id" AS customer_id,
  count(distinct "Order Id") AS n_orders
FROM supply_chain
GROUP BY "Customer Id";
"""
cust_counts = pd.read_sql_query(query_counts, connect)
cust_counts.head()

plt.figure(figsize=(10,5))
sns.barplot(x=cust_counts["n_orders"], y=cust_counts["customer_id"], palette='viridis')
plt.xlabel('Number of Orders per Customer')
plt.ylabel('Number of Customers')
plt.title('Distribution of Orders per Customer')
plt.show()                                            ### majority of the customer gives single order rather multiple.

query_repeat = """
SELECT
  SUM(CASE WHEN n_orders > 1 THEN 1 ELSE 0 END) * 100 / COUNT(*) AS repeat_rate_percentage,
  SUM(CASE WHEN n_orders > 1 THEN 1 ELSE 0 END) AS n_repeat_customers,
  COUNT(*) AS total_customers
FROM (
  SELECT COUNT(DISTINCT "Order Id") AS n_orders
  FROM supply_chain
  GROUP BY "Customer Id"
);
"""
repeat_stats = pd.read_sql_query(query_repeat, connect)

repeat_stats                                                         ### 57 % customer were repeated customer.
                                                                     ### total customer were 20641 among them repeat customers were 11768

query_dist = """
SELECT n_orders, COUNT(*) AS n_customers
FROM (
  SELECT "Customer Id", COUNT(DISTINCT "Order Id") AS n_orders
  FROM supply_chain
  GROUP BY "Customer Id"
)
GROUP BY n_orders
ORDER BY n_orders;
"""
dist = pd.read_sql_query(query_dist, connect)
dist.head(4)                                            #### majority of cutsomer were orderd for 1 order.

plt.figure(figsize=(8,5))
sns.barplot(x=dist["n_orders"], y=dist["n_customers"], palette='viridis')
plt.xlabel('Number of Orders per Customer')
plt.ylabel('Number of Customers')
plt.title('Distribution of Orders per Customer')
plt.tight_layout()
plt.show()

"""## Profit margins based on order volumes"""

query = '''
SELECT "Order Id",
       SUM("Order Item Quantity") AS order_volume,
       SUM("Order Profit Per Order") AS order_profit
FROM supply_chain
GROUP BY "Order Id";
'''
df_order = pd.read_sql_query(query, connect)
df_order.head()

                                                            ### as the number of  order item quantity increases the profit margin aslo increases.

Q3=df_order["order_volume"].quantile(0.75)             ### removing outliers from the data
Q1=df_order["order_volume"].quantile(0.25)
IQR_v=Q3-Q1

low_vol=Q1-IQR_v*1.5
high_vol=Q3+IQR_v*1.5

Q3_p=df_order["order_profit"].quantile(0.75)
Q1_p=df_order["order_profit"].quantile(0.25)
IQR_P=Q3_p -Q1_p
low_profit=Q1-IQR_P*1.5
high_profit=Q3=IQR_P*1.5

filtered=df_order[(df_order["order_volume"].between(low_vol, high_vol))&(df_order["order_profit"].between(low_profit,high_profit))]

plt.figure(figsize=(8,5))
sns.barplot(x=filtered['order_volume'], y=filtered['order_profit'], palette="inferno")
plt.xlabel('Order Volume (total items)')
plt.ylabel('Order Profit (sum)')
plt.title('Order Volume vs Order Profit')
plt.tight_layout()
plt.show()

query = '''
SELECT "Customer Country", "Product Name", SUM("Sales") AS total_sales
FROM supply_chain
GROUP BY "Customer Country", "Product Name"
ORDER BY "Customer ountry", total_sales DESC;
'''
df_prod_country = pd.read_sql_query(query, connect)
df_prod_country.head(5)

"""## Short summary of KPIs:"""

print("Executive Summary")
print(f"• Total Orders: {df['Order Id'].sum():,.2f}")
print(f"• Total Sales: ${df['Sales'].sum():,.2f}")
print(f"• Avg Profit per Order: ${df['Order Profit Per Order'].mean():.2f}")
print(f"• Repeat Purchase Rate: {repeat_rate:.2%}")
print(f"• Avg Delivery Delay: {df['Days for shipping (real)'].mean():.1f} days")

"""### Cohort Analysis (Distribution of days to second purchase)"""

# Get customer orders with dates
query_cohort = """
SELECT
    "Customer Id" AS customer_id,
    "Order Id" AS order_id,
    "order date (DateOrders)" AS order_date,
    "Sales" AS sales
FROM supply_chain
ORDER BY customer_id, order_date
"""
df_cohort = pd.read_sql_query(query_cohort, connect)
df_cohort

# # Convert to datetime
df_cohort['order_date'] = pd.to_datetime(df_cohort['order_date'], format="%m/%d/%Y %H:%M", errors='coerce')

# # Get first and subsequent orders for each customer
df_first_order = df_cohort.groupby('customer_id')['order_date'].min().reset_index()
df_first_order

df_first_order.columns = ['customer_id', 'first_order_date']

# Merge to get days since first order
df_cohort = df_cohort.merge(df_first_order, on='customer_id')
df_cohort['days_since_first_order'] = (df_cohort['order_date'] - df_cohort['first_order_date']).dt.days

# Get order number for each customer
df_cohort['order_number'] = df_cohort.groupby('customer_id').cumcount() + 1

# Analysis: Time between orders
df_repeat = df_cohort[df_cohort['order_number'] >= 2].copy()
df_second_order = df_cohort[df_cohort['order_number'] == 2].copy()

if len(df_second_order) > 0:
    print(" Time to Second Purchase:")
    print(f"   • Average days to 2nd order: {df_second_order['days_since_first_order'].mean():.1f} days")
    print(f"   • Median days to 2nd order: {df_second_order['days_since_first_order'].median():.1f} days")
    print(f"   • Min: {df_second_order['days_since_first_order'].min():.0f} days")
    print(f"   • Max: {df_second_order['days_since_first_order'].max():.0f} days")

# Visualization: Distribution of days to second purchase
    plt.figure(figsize=(8, 6))
    plt.hist(df_second_order['days_since_first_order'], bins=20, edgecolor='black', alpha=0.7)
    plt.axvline(df_second_order['days_since_first_order'].mean(), color='red',
                linestyle='--', linewidth=2, label=f'Mean: {df_second_order["days_since_first_order"].mean():.1f} days')
    plt.axvline(df_second_order['days_since_first_order'].median(), color='green',
                linestyle='--', linewidth=2, label=f'Median: {df_second_order["days_since_first_order"].median():.1f} days')
    plt.title('Time Between First and Second Purchase', fontsize=14, fontweight='bold')
    plt.xlabel('Days Since First Order')
    plt.ylabel('Number of Customers')
    plt.legend()
    plt.tight_layout()
    plt.show()

"""## Statistical analysis of Shipping mode and delivery days real"""

# Calculate averages for each shipping mode
averages = df.groupby('Shipping Mode')['Days for shipping (real)'].agg(['mean', 'count', 'std'])
print("Average delivery days by shipping mode:")
print(averages.round(2))

# Visualize the differences
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Shipping Mode', y='Days for shipping (real)', palette='Set2')
plt.title('Delivery Days by Shipping Mode', fontsize=14, fontweight='bold')
plt.ylabel('Delivery Days')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""### ANOVA"""

# Now runing the statistical test

# Split data by shipping mode
mode1 = df[df['Shipping Mode'] == 'Standard Class']['Days for shipping (real)']
mode2 = df[df['Shipping Mode'] == 'First Class']['Days for shipping (real)']
mode3 = df[df['Shipping Mode'] == 'Second Class']['Days for shipping (real)']
mode4 = df[df['Shipping Mode'] == 'Same Day']['Days for shipping (real)']

# Run ANOVA
f_stat, p_value = stats.f_oneway(mode1, mode2, mode3, mode4)


print(f"  F-statistic: {f_stat:.2f}")
print(f"  P-value: {p_value:.6f}")

# Interpret the result

if p_value < 0.05:
    print("  YES! The differences ARE statistically significant")
    print("  The shipping modes have REALLY different delivery times")
    print("  This is not just random variation")
else:
    print("  NO! The differences are NOT statistically significant")
    print("  The shipping modes might have similar delivery times")
    print("  Differences could be due to random chance")

"""### T test"""

# Run this to see WHICH modes are different
from itertools import combinations

modes = df['Shipping Mode'].unique()

print("Pairwise Comparisons:")
print("-" * 50)

for mode_a, mode_b in combinations(modes, 2):
    data_a = df[df['Shipping Mode'] == mode_a]['Days for shipping (real)']
    data_b = df[df['Shipping Mode'] == mode_b]['Days for shipping (real)']

    t_stat, p_val = stats.ttest_ind(data_a, data_b)

    diff = (data_a.mean() - data_b.mean())
   # Significance marker
    sig = (
        "***" if p_val < 0.001 else
        "**"  if p_val < 0.01 else
        "*"   if p_val < 0.05 else
        "ns"
    )

    print(f"{mode_a:20s} vs {mode_b:20s}: {diff:5.2f} days | {sig}")



